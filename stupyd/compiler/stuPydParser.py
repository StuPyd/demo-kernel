# Generated from /Users/muchen/python_smc/DemoKernel/stupyd/compiler/stuPyd.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3)")
        buf.write("\u0116\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\3\2\3\2\7\2;\n\2\f")
        buf.write("\2\16\2>\13\2\3\2\3\2\3\3\3\3\5\3D\n\3\3\4\3\4\3\4\7\4")
        buf.write("I\n\4\f\4\16\4L\13\4\3\4\5\4O\n\4\3\4\3\4\3\5\3\5\3\5")
        buf.write("\3\5\5\5W\n\5\3\6\3\6\5\6[\n\6\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\5\7e\n\7\3\b\6\bh\n\b\r\b\16\bi\3\t\3\t\3\t\3")
        buf.write("\n\3\n\3\13\3\13\3\13\7\13t\n\13\f\13\16\13w\13\13\3\13")
        buf.write("\3\13\3\f\3\f\3\f\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\7\16\u0089\n\16\f\16\16\16\u008c\13\16")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\7\17\u0097")
        buf.write("\n\17\f\17\16\17\u009a\13\17\3\20\3\20\3\20\3\20\5\20")
        buf.write("\u00a0\n\20\3\20\3\20\3\20\7\20\u00a5\n\20\f\20\16\20")
        buf.write("\u00a8\13\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3")
        buf.write("\21\3\21\3\21\5\21\u00b5\n\21\3\22\3\22\3\22\3\22\3\22")
        buf.write("\3\22\7\22\u00bd\n\22\f\22\16\22\u00c0\13\22\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\7\23\u00c8\n\23\f\23\16\23\u00cb")
        buf.write("\13\23\3\24\3\24\3\24\3\24\3\24\3\24\7\24\u00d3\n\24\f")
        buf.write("\24\16\24\u00d6\13\24\3\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\5\25\u00ec\n\25\3\26\3\26\3\26\3\26\3")
        buf.write("\26\3\26\5\26\u00f4\n\26\3\27\3\27\3\27\3\27\3\27\3\27")
        buf.write("\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\33")
        buf.write("\3\33\3\33\3\33\3\34\3\34\3\34\3\34\6\34\u010e\n\34\r")
        buf.write("\34\16\34\u010f\3\34\3\34\5\34\u0114\n\34\3\34\2\b\32")
        buf.write("\34\36\"$&\35\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 ")
        buf.write("\"$&(*,.\60\62\64\66\2\3\3\2\5\t\2\u011d\2<\3\2\2\2\4")
        buf.write("C\3\2\2\2\6E\3\2\2\2\bV\3\2\2\2\nZ\3\2\2\2\fd\3\2\2\2")
        buf.write("\16g\3\2\2\2\20k\3\2\2\2\22n\3\2\2\2\24p\3\2\2\2\26z\3")
        buf.write("\2\2\2\30}\3\2\2\2\32\177\3\2\2\2\34\u008d\3\2\2\2\36")
        buf.write("\u009f\3\2\2\2 \u00b4\3\2\2\2\"\u00b6\3\2\2\2$\u00c1\3")
        buf.write("\2\2\2&\u00cc\3\2\2\2(\u00eb\3\2\2\2*\u00f3\3\2\2\2,\u00f5")
        buf.write("\3\2\2\2.\u00fb\3\2\2\2\60\u00fe\3\2\2\2\62\u0102\3\2")
        buf.write("\2\2\64\u0105\3\2\2\2\66\u0113\3\2\2\28;\7!\2\29;\5\4")
        buf.write("\3\2:8\3\2\2\2:9\3\2\2\2;>\3\2\2\2<:\3\2\2\2<=\3\2\2\2")
        buf.write("=?\3\2\2\2><\3\2\2\2?@\7\2\2\3@\3\3\2\2\2AD\5\n\6\2BD")
        buf.write("\5\6\4\2CA\3\2\2\2CB\3\2\2\2D\5\3\2\2\2EJ\5\b\5\2FG\7")
        buf.write("\3\2\2GI\5\b\5\2HF\3\2\2\2IL\3\2\2\2JH\3\2\2\2JK\3\2\2")
        buf.write("\2KN\3\2\2\2LJ\3\2\2\2MO\7\3\2\2NM\3\2\2\2NO\3\2\2\2O")
        buf.write("P\3\2\2\2PQ\7!\2\2Q\7\3\2\2\2RW\5\16\b\2SW\5\f\7\2TW\5")
        buf.write("\32\16\2UW\5,\27\2VR\3\2\2\2VS\3\2\2\2VT\3\2\2\2VU\3\2")
        buf.write("\2\2W\t\3\2\2\2X[\5\62\32\2Y[\5.\30\2ZX\3\2\2\2ZY\3\2")
        buf.write("\2\2[\13\3\2\2\2\\]\5\32\16\2]^\7\4\2\2^_\5\30\r\2_e\3")
        buf.write("\2\2\2`a\5\"\22\2ab\7\4\2\2bc\5\30\r\2ce\3\2\2\2d\\\3")
        buf.write("\2\2\2d`\3\2\2\2e\r\3\2\2\2fh\5\20\t\2gf\3\2\2\2hi\3\2")
        buf.write("\2\2ig\3\2\2\2ij\3\2\2\2j\17\3\2\2\2kl\5\22\n\2lm\5\24")
        buf.write("\13\2m\21\3\2\2\2no\t\2\2\2o\23\3\2\2\2pu\5\26\f\2qr\7")
        buf.write("\n\2\2rt\5\26\f\2sq\3\2\2\2tw\3\2\2\2us\3\2\2\2uv\3\2")
        buf.write("\2\2vx\3\2\2\2wu\3\2\2\2xy\b\13\1\2y\25\3\2\2\2z{\7#\2")
        buf.write("\2{|\b\f\1\2|\27\3\2\2\2}~\7#\2\2~\31\3\2\2\2\177\u0080")
        buf.write("\b\16\1\2\u0080\u0081\5\34\17\2\u0081\u008a\3\2\2\2\u0082")
        buf.write("\u0083\f\5\2\2\u0083\u0084\7\13\2\2\u0084\u0089\5\34\17")
        buf.write("\2\u0085\u0086\f\4\2\2\u0086\u0087\7\f\2\2\u0087\u0089")
        buf.write("\5\34\17\2\u0088\u0082\3\2\2\2\u0088\u0085\3\2\2\2\u0089")
        buf.write("\u008c\3\2\2\2\u008a\u0088\3\2\2\2\u008a\u008b\3\2\2\2")
        buf.write("\u008b\33\3\2\2\2\u008c\u008a\3\2\2\2\u008d\u008e\b\17")
        buf.write("\1\2\u008e\u008f\5\36\20\2\u008f\u0098\3\2\2\2\u0090\u0091")
        buf.write("\f\5\2\2\u0091\u0092\7\r\2\2\u0092\u0097\5\36\20\2\u0093")
        buf.write("\u0094\f\4\2\2\u0094\u0095\7\16\2\2\u0095\u0097\5\36\20")
        buf.write("\2\u0096\u0090\3\2\2\2\u0096\u0093\3\2\2\2\u0097\u009a")
        buf.write("\3\2\2\2\u0098\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099")
        buf.write("\35\3\2\2\2\u009a\u0098\3\2\2\2\u009b\u009c\b\20\1\2\u009c")
        buf.write("\u009d\7\f\2\2\u009d\u00a0\5\36\20\5\u009e\u00a0\5 \21")
        buf.write("\2\u009f\u009b\3\2\2\2\u009f\u009e\3\2\2\2\u00a0\u00a6")
        buf.write("\3\2\2\2\u00a1\u00a2\f\4\2\2\u00a2\u00a3\7\17\2\2\u00a3")
        buf.write("\u00a5\5 \21\2\u00a4\u00a1\3\2\2\2\u00a5\u00a8\3\2\2\2")
        buf.write("\u00a6\u00a4\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\37\3\2")
        buf.write("\2\2\u00a8\u00a6\3\2\2\2\u00a9\u00b5\7 \2\2\u00aa\u00ab")
        buf.write("\7\20\2\2\u00ab\u00ac\5\32\16\2\u00ac\u00ad\7\21\2\2\u00ad")
        buf.write("\u00b5\3\2\2\2\u00ae\u00b5\7&\2\2\u00af\u00b5\5\30\r\2")
        buf.write("\u00b0\u00b1\7\20\2\2\u00b1\u00b2\5\"\22\2\u00b2\u00b3")
        buf.write("\7\21\2\2\u00b3\u00b5\3\2\2\2\u00b4\u00a9\3\2\2\2\u00b4")
        buf.write("\u00aa\3\2\2\2\u00b4\u00ae\3\2\2\2\u00b4\u00af\3\2\2\2")
        buf.write("\u00b4\u00b0\3\2\2\2\u00b5!\3\2\2\2\u00b6\u00b7\b\22\1")
        buf.write("\2\u00b7\u00b8\5$\23\2\u00b8\u00be\3\2\2\2\u00b9\u00ba")
        buf.write("\f\4\2\2\u00ba\u00bb\7\22\2\2\u00bb\u00bd\5$\23\2\u00bc")
        buf.write("\u00b9\3\2\2\2\u00bd\u00c0\3\2\2\2\u00be\u00bc\3\2\2\2")
        buf.write("\u00be\u00bf\3\2\2\2\u00bf#\3\2\2\2\u00c0\u00be\3\2\2")
        buf.write("\2\u00c1\u00c2\b\23\1\2\u00c2\u00c3\5&\24\2\u00c3\u00c9")
        buf.write("\3\2\2\2\u00c4\u00c5\f\4\2\2\u00c5\u00c6\7\23\2\2\u00c6")
        buf.write("\u00c8\5&\24\2\u00c7\u00c4\3\2\2\2\u00c8\u00cb\3\2\2\2")
        buf.write("\u00c9\u00c7\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca%\3\2\2")
        buf.write("\2\u00cb\u00c9\3\2\2\2\u00cc\u00cd\b\24\1\2\u00cd\u00ce")
        buf.write("\5(\25\2\u00ce\u00d4\3\2\2\2\u00cf\u00d0\f\4\2\2\u00d0")
        buf.write("\u00d1\7\24\2\2\u00d1\u00d3\5(\25\2\u00d2\u00cf\3\2\2")
        buf.write("\2\u00d3\u00d6\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4\u00d5")
        buf.write("\3\2\2\2\u00d5\'\3\2\2\2\u00d6\u00d4\3\2\2\2\u00d7\u00d8")
        buf.write("\5\32\16\2\u00d8\u00d9\7\25\2\2\u00d9\u00da\5\32\16\2")
        buf.write("\u00da\u00ec\3\2\2\2\u00db\u00dc\5\32\16\2\u00dc\u00dd")
        buf.write("\7\26\2\2\u00dd\u00de\5\32\16\2\u00de\u00ec\3\2\2\2\u00df")
        buf.write("\u00e0\5\32\16\2\u00e0\u00e1\7\27\2\2\u00e1\u00e2\5\32")
        buf.write("\16\2\u00e2\u00ec\3\2\2\2\u00e3\u00e4\5\32\16\2\u00e4")
        buf.write("\u00e5\7\30\2\2\u00e5\u00e6\5\32\16\2\u00e6\u00ec\3\2")
        buf.write("\2\2\u00e7\u00e8\7\31\2\2\u00e8\u00ec\5*\26\2\u00e9\u00ec")
        buf.write("\5*\26\2\u00ea\u00ec\5\30\r\2\u00eb\u00d7\3\2\2\2\u00eb")
        buf.write("\u00db\3\2\2\2\u00eb\u00df\3\2\2\2\u00eb\u00e3\3\2\2\2")
        buf.write("\u00eb\u00e7\3\2\2\2\u00eb\u00e9\3\2\2\2\u00eb\u00ea\3")
        buf.write("\2\2\2\u00ec)\3\2\2\2\u00ed\u00f4\7\32\2\2\u00ee\u00f4")
        buf.write("\7\33\2\2\u00ef\u00f0\7\20\2\2\u00f0\u00f1\5\"\22\2\u00f1")
        buf.write("\u00f2\7\21\2\2\u00f2\u00f4\3\2\2\2\u00f3\u00ed\3\2\2")
        buf.write("\2\u00f3\u00ee\3\2\2\2\u00f3\u00ef\3\2\2\2\u00f4+\3\2")
        buf.write("\2\2\u00f5\u00f6\7\34\2\2\u00f6\u00f7\7\20\2\2\u00f7\u00f8")
        buf.write("\5\32\16\2\u00f8\u00f9\7\21\2\2\u00f9\u00fa\7!\2\2\u00fa")
        buf.write("-\3\2\2\2\u00fb\u00fc\5\60\31\2\u00fc\u00fd\5\66\34\2")
        buf.write("\u00fd/\3\2\2\2\u00fe\u00ff\7\35\2\2\u00ff\u0100\5\"\22")
        buf.write("\2\u0100\u0101\7\36\2\2\u0101\61\3\2\2\2\u0102\u0103\5")
        buf.write("\64\33\2\u0103\u0104\5\66\34\2\u0104\63\3\2\2\2\u0105")
        buf.write("\u0106\7\37\2\2\u0106\u0107\5\"\22\2\u0107\u0108\7\36")
        buf.write("\2\2\u0108\65\3\2\2\2\u0109\u0114\5\6\4\2\u010a\u010b")
        buf.write("\7!\2\2\u010b\u010d\7(\2\2\u010c\u010e\5\4\3\2\u010d\u010c")
        buf.write("\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u010d\3\2\2\2\u010f")
        buf.write("\u0110\3\2\2\2\u0110\u0111\3\2\2\2\u0111\u0112\7)\2\2")
        buf.write("\u0112\u0114\3\2\2\2\u0113\u0109\3\2\2\2\u0113\u010a\3")
        buf.write("\2\2\2\u0114\67\3\2\2\2\32:<CJNVZdiu\u0088\u008a\u0096")
        buf.write("\u0098\u009f\u00a6\u00b4\u00be\u00c9\u00d4\u00eb\u00f3")
        buf.write("\u010f\u0113")
        return buf.getvalue()


class stuPydParser ( Parser ):

    grammarFileName = "stuPyd.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'->'", "'num'", "'bool'", "'string'", 
                     "'void'", "'struct'", "','", "'+'", "'-'", "'*'", "'/'", 
                     "'^'", "'('", "')'", "'|'", "'&'", "'='", "'>'", "'<'", 
                     "'>='", "'<='", "'!'", "'TRUE'", "'FALSE'", "'print'", 
                     "'while'", "':'", "'if'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "NUMBER", "NEWLINE", "BLANK", 
                      "ID", "INT", "FLOAT", "STRING", "CHAR", "INDENT", 
                      "DEDENT" ]

    RULE_file_input = 0
    RULE_stmt = 1
    RULE_simple_stmt = 2
    RULE_small_stmt = 3
    RULE_compound_stmt = 4
    RULE_gv_stmt = 5
    RULE_decls = 6
    RULE_decl = 7
    RULE_vartype = 8
    RULE_tarlist = 9
    RULE_target = 10
    RULE_prmy = 11
    RULE_expr = 12
    RULE_term = 13
    RULE_unary = 14
    RULE_factor = 15
    RULE_boolval = 16
    RULE_join = 17
    RULE_equality = 18
    RULE_rel = 19
    RULE_basebool = 20
    RULE_output = 21
    RULE_while_stmt = 22
    RULE_while_judge = 23
    RULE_if_stmt = 24
    RULE_if_judge = 25
    RULE_suite = 26

    ruleNames =  [ "file_input", "stmt", "simple_stmt", "small_stmt", "compound_stmt", 
                   "gv_stmt", "decls", "decl", "vartype", "tarlist", "target", 
                   "prmy", "expr", "term", "unary", "factor", "boolval", 
                   "join", "equality", "rel", "basebool", "output", "while_stmt", 
                   "while_judge", "if_stmt", "if_judge", "suite" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    NUMBER=30
    NEWLINE=31
    BLANK=32
    ID=33
    INT=34
    FLOAT=35
    STRING=36
    CHAR=37
    INDENT=38
    DEDENT=39

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class File_inputContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(stuPydParser.EOF, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(stuPydParser.NEWLINE)
            else:
                return self.getToken(stuPydParser.NEWLINE, i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.StmtContext)
            else:
                return self.getTypedRuleContext(stuPydParser.StmtContext,i)


        def getRuleIndex(self):
            return stuPydParser.RULE_file_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_input" ):
                listener.enterFile_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_input" ):
                listener.exitFile_input(self)




    def file_input(self):

        localctx = stuPydParser.File_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_file_input)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stuPydParser.T__2) | (1 << stuPydParser.T__3) | (1 << stuPydParser.T__4) | (1 << stuPydParser.T__5) | (1 << stuPydParser.T__6) | (1 << stuPydParser.T__9) | (1 << stuPydParser.T__13) | (1 << stuPydParser.T__22) | (1 << stuPydParser.T__23) | (1 << stuPydParser.T__24) | (1 << stuPydParser.T__25) | (1 << stuPydParser.T__26) | (1 << stuPydParser.T__28) | (1 << stuPydParser.NUMBER) | (1 << stuPydParser.NEWLINE) | (1 << stuPydParser.ID) | (1 << stuPydParser.STRING))) != 0):
                self.state = 56
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [stuPydParser.NEWLINE]:
                    self.state = 54
                    self.match(stuPydParser.NEWLINE)
                    pass
                elif token in [stuPydParser.T__2, stuPydParser.T__3, stuPydParser.T__4, stuPydParser.T__5, stuPydParser.T__6, stuPydParser.T__9, stuPydParser.T__13, stuPydParser.T__22, stuPydParser.T__23, stuPydParser.T__24, stuPydParser.T__25, stuPydParser.T__26, stuPydParser.T__28, stuPydParser.NUMBER, stuPydParser.ID, stuPydParser.STRING]:
                    self.state = 55
                    self.stmt()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 61
            self.match(stuPydParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compound_stmt(self):
            return self.getTypedRuleContext(stuPydParser.Compound_stmtContext,0)


        def simple_stmt(self):
            return self.getTypedRuleContext(stuPydParser.Simple_stmtContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)




    def stmt(self):

        localctx = stuPydParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stmt)
        try:
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stuPydParser.T__26, stuPydParser.T__28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 63
                self.compound_stmt()
                pass
            elif token in [stuPydParser.T__2, stuPydParser.T__3, stuPydParser.T__4, stuPydParser.T__5, stuPydParser.T__6, stuPydParser.T__9, stuPydParser.T__13, stuPydParser.T__22, stuPydParser.T__23, stuPydParser.T__24, stuPydParser.T__25, stuPydParser.NUMBER, stuPydParser.ID, stuPydParser.STRING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 64
                self.simple_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def small_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.Small_stmtContext)
            else:
                return self.getTypedRuleContext(stuPydParser.Small_stmtContext,i)


        def NEWLINE(self):
            return self.getToken(stuPydParser.NEWLINE, 0)

        def getRuleIndex(self):
            return stuPydParser.RULE_simple_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_stmt" ):
                listener.enterSimple_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_stmt" ):
                listener.exitSimple_stmt(self)




    def simple_stmt(self):

        localctx = stuPydParser.Simple_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_simple_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.small_stmt()
            self.state = 72
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 68
                    self.match(stuPydParser.T__0)
                    self.state = 69
                    self.small_stmt() 
                self.state = 74
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==stuPydParser.T__0:
                self.state = 75
                self.match(stuPydParser.T__0)


            self.state = 78
            self.match(stuPydParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Small_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decls(self):
            return self.getTypedRuleContext(stuPydParser.DeclsContext,0)


        def gv_stmt(self):
            return self.getTypedRuleContext(stuPydParser.Gv_stmtContext,0)


        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)


        def output(self):
            return self.getTypedRuleContext(stuPydParser.OutputContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_small_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSmall_stmt" ):
                listener.enterSmall_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSmall_stmt" ):
                listener.exitSmall_stmt(self)




    def small_stmt(self):

        localctx = stuPydParser.Small_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_small_stmt)
        try:
            self.state = 84
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 80
                self.decls()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 81
                self.gv_stmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 82
                self.expr(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 83
                self.output()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_stmt(self):
            return self.getTypedRuleContext(stuPydParser.If_stmtContext,0)


        def while_stmt(self):
            return self.getTypedRuleContext(stuPydParser.While_stmtContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_compound_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompound_stmt" ):
                listener.enterCompound_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompound_stmt" ):
                listener.exitCompound_stmt(self)




    def compound_stmt(self):

        localctx = stuPydParser.Compound_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_compound_stmt)
        try:
            self.state = 88
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stuPydParser.T__28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 86
                self.if_stmt()
                pass
            elif token in [stuPydParser.T__26]:
                self.enterOuterAlt(localctx, 2)
                self.state = 87
                self.while_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Gv_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_gv_stmt

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GvExpContext(Gv_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.Gv_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)

        def prmy(self):
            return self.getTypedRuleContext(stuPydParser.PrmyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGvExp" ):
                listener.enterGvExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGvExp" ):
                listener.exitGvExp(self)


    class GvBoolContext(Gv_stmtContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.Gv_stmtContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)

        def prmy(self):
            return self.getTypedRuleContext(stuPydParser.PrmyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGvBool" ):
                listener.enterGvBool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGvBool" ):
                listener.exitGvBool(self)



    def gv_stmt(self):

        localctx = stuPydParser.Gv_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_gv_stmt)
        try:
            self.state = 98
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = stuPydParser.GvExpContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 90
                self.expr(0)
                self.state = 91
                self.match(stuPydParser.T__1)
                self.state = 92
                self.prmy()
                pass

            elif la_ == 2:
                localctx = stuPydParser.GvBoolContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self.boolval(0)
                self.state = 95
                self.match(stuPydParser.T__1)
                self.state = 96
                self.prmy()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.DeclContext)
            else:
                return self.getTypedRuleContext(stuPydParser.DeclContext,i)


        def getRuleIndex(self):
            return stuPydParser.RULE_decls

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecls" ):
                listener.enterDecls(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecls" ):
                listener.exitDecls(self)




    def decls(self):

        localctx = stuPydParser.DeclsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_decls)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 100
                self.decl()
                self.state = 103 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stuPydParser.T__2) | (1 << stuPydParser.T__3) | (1 << stuPydParser.T__4) | (1 << stuPydParser.T__5) | (1 << stuPydParser.T__6))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vartype(self):
            return self.getTypedRuleContext(stuPydParser.VartypeContext,0)


        def tarlist(self):
            return self.getTypedRuleContext(stuPydParser.TarlistContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecl" ):
                listener.enterDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecl" ):
                listener.exitDecl(self)




    def decl(self):

        localctx = stuPydParser.DeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.vartype()
            self.state = 106
            self.tarlist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VartypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_vartype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVartype" ):
                listener.enterVartype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVartype" ):
                listener.exitVartype(self)




    def vartype(self):

        localctx = stuPydParser.VartypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_vartype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stuPydParser.T__2) | (1 << stuPydParser.T__3) | (1 << stuPydParser.T__4) | (1 << stuPydParser.T__5) | (1 << stuPydParser.T__6))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TarlistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def target(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.TargetContext)
            else:
                return self.getTypedRuleContext(stuPydParser.TargetContext,i)


        def getRuleIndex(self):
            return stuPydParser.RULE_tarlist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarlist" ):
                listener.enterTarlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarlist" ):
                listener.exitTarlist(self)




    def tarlist(self):

        localctx = stuPydParser.TarlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_tarlist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.target()
            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==stuPydParser.T__7:
                self.state = 111
                self.match(stuPydParser.T__7)
                self.state = 112
                self.target()
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TargetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(stuPydParser.ID, 0)

        def getRuleIndex(self):
            return stuPydParser.RULE_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget" ):
                listener.enterTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget" ):
                listener.exitTarget(self)




    def target(self):

        localctx = stuPydParser.TargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_target)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(stuPydParser.ID)


            	
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrmyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(stuPydParser.ID, 0)

        def getRuleIndex(self):
            return stuPydParser.RULE_prmy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrmy" ):
                listener.enterPrmy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrmy" ):
                listener.exitPrmy(self)




    def prmy(self):

        localctx = stuPydParser.PrmyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_prmy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(stuPydParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class EtermContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(stuPydParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEterm" ):
                listener.enterEterm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEterm" ):
                listener.exitEterm(self)


    class EsubContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)

        def term(self):
            return self.getTypedRuleContext(stuPydParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEsub" ):
                listener.enterEsub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEsub" ):
                listener.exitEsub(self)


    class EaddContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)

        def term(self):
            return self.getTypedRuleContext(stuPydParser.TermContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEadd" ):
                listener.enterEadd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEadd" ):
                listener.exitEadd(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_expr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = stuPydParser.EtermContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 126
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 136
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,11,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 134
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                    if la_ == 1:
                        localctx = stuPydParser.EaddContext(self, stuPydParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 128
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 129
                        self.match(stuPydParser.T__8)
                        self.state = 130
                        self.term(0)
                        pass

                    elif la_ == 2:
                        localctx = stuPydParser.EsubContext(self, stuPydParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 131
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 132
                        self.match(stuPydParser.T__9)
                        self.state = 133
                        self.term(0)
                        pass

             
                self.state = 138
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_term

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class TunaryContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary(self):
            return self.getTypedRuleContext(stuPydParser.UnaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTunary" ):
                listener.enterTunary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTunary" ):
                listener.exitTunary(self)


    class TmulContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(stuPydParser.TermContext,0)

        def unary(self):
            return self.getTypedRuleContext(stuPydParser.UnaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTmul" ):
                listener.enterTmul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTmul" ):
                listener.exitTmul(self)


    class TdivContext(TermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.TermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def term(self):
            return self.getTypedRuleContext(stuPydParser.TermContext,0)

        def unary(self):
            return self.getTypedRuleContext(stuPydParser.UnaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTdiv" ):
                listener.enterTdiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTdiv" ):
                listener.exitTdiv(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 26
        self.enterRecursionRule(localctx, 26, self.RULE_term, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = stuPydParser.TunaryContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 140
            self.unary(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 150
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 148
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                    if la_ == 1:
                        localctx = stuPydParser.TmulContext(self, stuPydParser.TermContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                        self.state = 142
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 143
                        self.match(stuPydParser.T__10)
                        self.state = 144
                        self.unary(0)
                        pass

                    elif la_ == 2:
                        localctx = stuPydParser.TdivContext(self, stuPydParser.TermContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                        self.state = 145
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 146
                        self.match(stuPydParser.T__11)
                        self.state = 147
                        self.unary(0)
                        pass

             
                self.state = 152
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class UnaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_unary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class UdisContext(UnaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.UnaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary(self):
            return self.getTypedRuleContext(stuPydParser.UnaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUdis" ):
                listener.enterUdis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUdis" ):
                listener.exitUdis(self)


    class UsqrContext(UnaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.UnaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unary(self):
            return self.getTypedRuleContext(stuPydParser.UnaryContext,0)

        def factor(self):
            return self.getTypedRuleContext(stuPydParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUsqr" ):
                listener.enterUsqr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUsqr" ):
                listener.exitUsqr(self)


    class UfacContext(UnaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.UnaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def factor(self):
            return self.getTypedRuleContext(stuPydParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUfac" ):
                listener.enterUfac(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUfac" ):
                listener.exitUfac(self)



    def unary(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.UnaryContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 28
        self.enterRecursionRule(localctx, 28, self.RULE_unary, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stuPydParser.T__9]:
                localctx = stuPydParser.UdisContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 154
                self.match(stuPydParser.T__9)
                self.state = 155
                self.unary(3)
                pass
            elif token in [stuPydParser.T__13, stuPydParser.NUMBER, stuPydParser.ID, stuPydParser.STRING]:
                localctx = stuPydParser.UfacContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 156
                self.factor()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 164
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = stuPydParser.UsqrContext(self, stuPydParser.UnaryContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_unary)
                    self.state = 159
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 160
                    self.match(stuPydParser.T__12)
                    self.state = 161
                    self.factor() 
                self.state = 166
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_factor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FnumContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(stuPydParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFnum" ):
                listener.enterFnum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFnum" ):
                listener.exitFnum(self)


    class FboolContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFbool" ):
                listener.enterFbool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFbool" ):
                listener.exitFbool(self)


    class FincContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinc" ):
                listener.enterFinc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinc" ):
                listener.exitFinc(self)


    class FStringContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(stuPydParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFString" ):
                listener.enterFString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFString" ):
                listener.exitFString(self)


    class FprmyContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def prmy(self):
            return self.getTypedRuleContext(stuPydParser.PrmyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFprmy" ):
                listener.enterFprmy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFprmy" ):
                listener.exitFprmy(self)



    def factor(self):

        localctx = stuPydParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_factor)
        try:
            self.state = 178
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                localctx = stuPydParser.FnumContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.match(stuPydParser.NUMBER)
                pass

            elif la_ == 2:
                localctx = stuPydParser.FincContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 168
                self.match(stuPydParser.T__13)
                self.state = 169
                self.expr(0)
                self.state = 170
                self.match(stuPydParser.T__14)
                pass

            elif la_ == 3:
                localctx = stuPydParser.FStringContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 172
                self.match(stuPydParser.STRING)
                pass

            elif la_ == 4:
                localctx = stuPydParser.FprmyContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 173
                self.prmy()
                pass

            elif la_ == 5:
                localctx = stuPydParser.FboolContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 174
                self.match(stuPydParser.T__13)
                self.state = 175
                self.boolval(0)
                self.state = 176
                self.match(stuPydParser.T__14)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolvalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_boolval

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class BorContext(BoolvalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.BoolvalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)

        def join(self):
            return self.getTypedRuleContext(stuPydParser.JoinContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBor" ):
                listener.enterBor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBor" ):
                listener.exitBor(self)


    class BjoinContext(BoolvalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.BoolvalContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def join(self):
            return self.getTypedRuleContext(stuPydParser.JoinContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBjoin" ):
                listener.enterBjoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBjoin" ):
                listener.exitBjoin(self)



    def boolval(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.BoolvalContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_boolval, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = stuPydParser.BjoinContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 181
            self.join(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 188
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = stuPydParser.BorContext(self, stuPydParser.BoolvalContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_boolval)
                    self.state = 183
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 184
                    self.match(stuPydParser.T__15)
                    self.state = 185
                    self.join(0) 
                self.state = 190
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class JoinContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_join

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class JeqlContext(JoinContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.JoinContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def equality(self):
            return self.getTypedRuleContext(stuPydParser.EqualityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJeql" ):
                listener.enterJeql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJeql" ):
                listener.exitJeql(self)


    class JandContext(JoinContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.JoinContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def join(self):
            return self.getTypedRuleContext(stuPydParser.JoinContext,0)

        def equality(self):
            return self.getTypedRuleContext(stuPydParser.EqualityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJand" ):
                listener.enterJand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJand" ):
                listener.exitJand(self)



    def join(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.JoinContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_join, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = stuPydParser.JeqlContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 192
            self.equality(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 199
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = stuPydParser.JandContext(self, stuPydParser.JoinContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_join)
                    self.state = 194
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 195
                    self.match(stuPydParser.T__16)
                    self.state = 196
                    self.equality(0) 
                self.state = 201
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class EqualityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_equality

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ErelContext(EqualityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.EqualityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rel(self):
            return self.getTypedRuleContext(stuPydParser.RelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterErel" ):
                listener.enterErel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitErel" ):
                listener.exitErel(self)


    class EeqlContext(EqualityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.EqualityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def equality(self):
            return self.getTypedRuleContext(stuPydParser.EqualityContext,0)

        def rel(self):
            return self.getTypedRuleContext(stuPydParser.RelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEeql" ):
                listener.enterEeql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEeql" ):
                listener.exitEeql(self)



    def equality(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stuPydParser.EqualityContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_equality, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = stuPydParser.ErelContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 203
            self.rel()
            self._ctx.stop = self._input.LT(-1)
            self.state = 210
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = stuPydParser.EeqlContext(self, stuPydParser.EqualityContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_equality)
                    self.state = 205
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 206
                    self.match(stuPydParser.T__17)
                    self.state = 207
                    self.rel() 
                self.state = 212
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class RelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_rel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RbaseContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def basebool(self):
            return self.getTypedRuleContext(stuPydParser.BaseboolContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRbase" ):
                listener.enterRbase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRbase" ):
                listener.exitRbase(self)


    class RbeContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.ExprContext)
            else:
                return self.getTypedRuleContext(stuPydParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRbe" ):
                listener.enterRbe(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRbe" ):
                listener.exitRbe(self)


    class RseContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.ExprContext)
            else:
                return self.getTypedRuleContext(stuPydParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRse" ):
                listener.enterRse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRse" ):
                listener.exitRse(self)


    class RsmlContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.ExprContext)
            else:
                return self.getTypedRuleContext(stuPydParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRsml" ):
                listener.enterRsml(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRsml" ):
                listener.exitRsml(self)


    class RnotContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def basebool(self):
            return self.getTypedRuleContext(stuPydParser.BaseboolContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRnot" ):
                listener.enterRnot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRnot" ):
                listener.exitRnot(self)


    class RbigContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.ExprContext)
            else:
                return self.getTypedRuleContext(stuPydParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRbig" ):
                listener.enterRbig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRbig" ):
                listener.exitRbig(self)


    class RprmyContext(RelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.RelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def prmy(self):
            return self.getTypedRuleContext(stuPydParser.PrmyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRprmy" ):
                listener.enterRprmy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRprmy" ):
                listener.exitRprmy(self)



    def rel(self):

        localctx = stuPydParser.RelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_rel)
        try:
            self.state = 233
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                localctx = stuPydParser.RbigContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 213
                self.expr(0)
                self.state = 214
                self.match(stuPydParser.T__18)
                self.state = 215
                self.expr(0)
                pass

            elif la_ == 2:
                localctx = stuPydParser.RsmlContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 217
                self.expr(0)
                self.state = 218
                self.match(stuPydParser.T__19)
                self.state = 219
                self.expr(0)
                pass

            elif la_ == 3:
                localctx = stuPydParser.RbeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 221
                self.expr(0)
                self.state = 222
                self.match(stuPydParser.T__20)
                self.state = 223
                self.expr(0)
                pass

            elif la_ == 4:
                localctx = stuPydParser.RseContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 225
                self.expr(0)
                self.state = 226
                self.match(stuPydParser.T__21)
                self.state = 227
                self.expr(0)
                pass

            elif la_ == 5:
                localctx = stuPydParser.RnotContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 229
                self.match(stuPydParser.T__22)
                self.state = 230
                self.basebool()
                pass

            elif la_ == 6:
                localctx = stuPydParser.RbaseContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 231
                self.basebool()
                pass

            elif la_ == 7:
                localctx = stuPydParser.RprmyContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 232
                self.prmy()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BaseboolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stuPydParser.RULE_basebool

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BincContext(BaseboolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.BaseboolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinc" ):
                listener.enterBinc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinc" ):
                listener.exitBinc(self)


    class BtrueContext(BaseboolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.BaseboolContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBtrue" ):
                listener.enterBtrue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBtrue" ):
                listener.exitBtrue(self)


    class BfalseContext(BaseboolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a stuPydParser.BaseboolContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBfalse" ):
                listener.enterBfalse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBfalse" ):
                listener.exitBfalse(self)



    def basebool(self):

        localctx = stuPydParser.BaseboolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_basebool)
        try:
            self.state = 241
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stuPydParser.T__23]:
                localctx = stuPydParser.BtrueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 235
                self.match(stuPydParser.T__23)
                pass
            elif token in [stuPydParser.T__24]:
                localctx = stuPydParser.BfalseContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 236
                self.match(stuPydParser.T__24)
                pass
            elif token in [stuPydParser.T__13]:
                localctx = stuPydParser.BincContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 237
                self.match(stuPydParser.T__13)
                self.state = 238
                self.boolval(0)
                self.state = 239
                self.match(stuPydParser.T__14)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OutputContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(stuPydParser.ExprContext,0)


        def NEWLINE(self):
            return self.getToken(stuPydParser.NEWLINE, 0)

        def getRuleIndex(self):
            return stuPydParser.RULE_output

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutput" ):
                listener.enterOutput(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutput" ):
                listener.exitOutput(self)




    def output(self):

        localctx = stuPydParser.OutputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_output)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(stuPydParser.T__25)
            self.state = 244
            self.match(stuPydParser.T__13)
            self.state = 245
            self.expr(0)
            self.state = 246
            self.match(stuPydParser.T__14)
            self.state = 247
            self.match(stuPydParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class While_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def while_judge(self):
            return self.getTypedRuleContext(stuPydParser.While_judgeContext,0)


        def suite(self):
            return self.getTypedRuleContext(stuPydParser.SuiteContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_while_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_stmt" ):
                listener.enterWhile_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_stmt" ):
                listener.exitWhile_stmt(self)




    def while_stmt(self):

        localctx = stuPydParser.While_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_while_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.while_judge()
            self.state = 250
            self.suite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class While_judgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_while_judge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_judge" ):
                listener.enterWhile_judge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_judge" ):
                listener.exitWhile_judge(self)




    def while_judge(self):

        localctx = stuPydParser.While_judgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_while_judge)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(stuPydParser.T__26)
            self.state = 253
            self.boolval(0)
            self.state = 254
            self.match(stuPydParser.T__27)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_judge(self):
            return self.getTypedRuleContext(stuPydParser.If_judgeContext,0)


        def suite(self):
            return self.getTypedRuleContext(stuPydParser.SuiteContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_if_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_stmt" ):
                listener.enterIf_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_stmt" ):
                listener.exitIf_stmt(self)




    def if_stmt(self):

        localctx = stuPydParser.If_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_if_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.if_judge()
            self.state = 257
            self.suite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_judgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolval(self):
            return self.getTypedRuleContext(stuPydParser.BoolvalContext,0)


        def getRuleIndex(self):
            return stuPydParser.RULE_if_judge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_judge" ):
                listener.enterIf_judge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_judge" ):
                listener.exitIf_judge(self)




    def if_judge(self):

        localctx = stuPydParser.If_judgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_if_judge)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(stuPydParser.T__28)
            self.state = 260
            self.boolval(0)
            self.state = 261
            self.match(stuPydParser.T__27)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SuiteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_stmt(self):
            return self.getTypedRuleContext(stuPydParser.Simple_stmtContext,0)


        def NEWLINE(self):
            return self.getToken(stuPydParser.NEWLINE, 0)

        def INDENT(self):
            return self.getToken(stuPydParser.INDENT, 0)

        def DEDENT(self):
            return self.getToken(stuPydParser.DEDENT, 0)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stuPydParser.StmtContext)
            else:
                return self.getTypedRuleContext(stuPydParser.StmtContext,i)


        def getRuleIndex(self):
            return stuPydParser.RULE_suite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuite" ):
                listener.enterSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuite" ):
                listener.exitSuite(self)




    def suite(self):

        localctx = stuPydParser.SuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_suite)
        self._la = 0 # Token type
        try:
            self.state = 273
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stuPydParser.T__2, stuPydParser.T__3, stuPydParser.T__4, stuPydParser.T__5, stuPydParser.T__6, stuPydParser.T__9, stuPydParser.T__13, stuPydParser.T__22, stuPydParser.T__23, stuPydParser.T__24, stuPydParser.T__25, stuPydParser.NUMBER, stuPydParser.ID, stuPydParser.STRING]:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.simple_stmt()
                pass
            elif token in [stuPydParser.NEWLINE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                self.match(stuPydParser.NEWLINE)
                self.state = 265
                self.match(stuPydParser.INDENT)
                self.state = 267 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 266
                    self.stmt()
                    self.state = 269 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stuPydParser.T__2) | (1 << stuPydParser.T__3) | (1 << stuPydParser.T__4) | (1 << stuPydParser.T__5) | (1 << stuPydParser.T__6) | (1 << stuPydParser.T__9) | (1 << stuPydParser.T__13) | (1 << stuPydParser.T__22) | (1 << stuPydParser.T__23) | (1 << stuPydParser.T__24) | (1 << stuPydParser.T__25) | (1 << stuPydParser.T__26) | (1 << stuPydParser.T__28) | (1 << stuPydParser.NUMBER) | (1 << stuPydParser.ID) | (1 << stuPydParser.STRING))) != 0)):
                        break

                self.state = 271
                self.match(stuPydParser.DEDENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[12] = self.expr_sempred
        self._predicates[13] = self.term_sempred
        self._predicates[14] = self.unary_sempred
        self._predicates[16] = self.boolval_sempred
        self._predicates[17] = self.join_sempred
        self._predicates[18] = self.equality_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

    def unary_sempred(self, localctx:UnaryContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         

    def boolval_sempred(self, localctx:BoolvalContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         

    def join_sempred(self, localctx:JoinContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

    def equality_sempred(self, localctx:EqualityContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 2)
         




